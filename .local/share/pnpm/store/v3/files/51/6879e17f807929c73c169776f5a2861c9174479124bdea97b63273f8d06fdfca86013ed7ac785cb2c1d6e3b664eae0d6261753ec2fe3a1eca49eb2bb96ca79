"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = __importDefault(require("events"));
/**
 * APDU transport layer allowing third-party developers to make raw calls
 * to a Ledger device.
 */
class LedgerPlatformApduTransport {
    constructor() {
        this._events = new events_1.default();
    }
    /**
     * low level api to communicate with the device
     * This method is for implementations to implement but should not be directly called.
     * Instead, the recommanded way is to use send() method
     * @param apdu the data to send
     * @return a Promise of response data
     */
    exchange(_apdu) {
        throw new Error("Function is not implemented yet");
    }
    /**
     * set the "scramble key" for the next exchanges with the device.
     * Each App can have a different scramble key and they internally will set it at instanciation.
     * @param key the scramble key
     */
    setScrambleKey(_key) {
        throw new Error("Function is not implemented yet");
    }
    /**
     * close the exchange with the device.
     * @return a Promise that ends when the transport is closed.
     */
    close() {
        throw new Error("Function is not implemented yet");
    }
    /**
     * Listen to an event on an instance of transport.
     * Transport implementation can have specific events. Here is the common events:
     * * `"disconnect"` : triggered if Transport is disconnected
     */
    on(eventName, cb) {
        this._events.on(eventName, cb);
    }
    /**
     * Stop listening to an event on an instance of transport.
     */
    off(eventName, cb) {
        this._events.removeListener(eventName, cb);
    }
    /**
     * Enable or not logs of the binary exchange
     */
    setDebugMode() {
        throw new Error("Function is not implemented yet");
    }
    /**
     * Set a timeout (in milliseconds) for the exchange call. Only some transport might implement it. (e.g. U2F)
     */
    setExchangeTimeout(_exchangeTimeout) {
        throw new Error("Function is not implemented yet");
    }
    /**
     * Define the delay before emitting "unresponsive" on an exchange that does not respond
     */
    setExchangeUnresponsiveTimeout(_unresponsiveTimeout) {
        throw new Error("Function is not implemented yet");
    }
    /**
     * wrapper on top of exchange to simplify work of the implementation.
     * @param cla
     * @param ins
     * @param p1
     * @param p2
     * @param data
     * @param statusList is a list of accepted status code (shorts). [0x9000] by default
     * @return a Promise of response buffer
     */
    send(_cla, _ins, _p1, _p2, _data = Buffer.alloc(0), _statusList = [0x9000]) {
        return __awaiter(this, void 0, void 0, function* () {
            throw new Error("Function is not implemented yet");
        });
    }
}
exports.default = LedgerPlatformApduTransport;
