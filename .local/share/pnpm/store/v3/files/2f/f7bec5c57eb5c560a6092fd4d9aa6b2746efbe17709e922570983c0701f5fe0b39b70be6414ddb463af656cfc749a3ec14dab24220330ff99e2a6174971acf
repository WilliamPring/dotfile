import { b58cencode, ProhibitedActionError, prefix, Prefix } from '@taquito/utils';
import { hash } from '@stablelib/blake2b';

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

/*
 * Some code in this file is adapted from sotez
 * Copyright (c) 2018 Andrew Kishino
 */
const MAX_CHUNK_SIZE = 230;
/**
 *
 * @description Convert the path to a buffer that will be used as LC and CDATA in the APDU send to the ledger device (https://github.com/obsidiansystems/ledger-app-tezos/blob/master/APDUs.md)
 *
 * @param path The ledger derivation path (default is "44'/1729'/0'/0'")
 * @returns A buffer where the first element is the length of the path (default is 4), then 3 bytes for each number of the path to which is added 0x8000000
 */
function transformPathToBuffer(path) {
    const result = [];
    const components = path.split('/');
    components.forEach((element) => {
        let toNumber = parseInt(element, 10);
        if (Number.isNaN(toNumber)) {
            return;
        }
        if (element.length > 1 && element[element.length - 1] === "'") {
            toNumber += 0x80000000;
        }
        result.push(toNumber);
    });
    const buffer = Buffer.alloc(1 + result.length * 4);
    buffer[0] = result.length;
    result.forEach((element, index) => {
        buffer.writeUInt32BE(element, 1 + 4 * index);
    });
    return buffer;
}
/**
 *
 * @description Converts uncompressed ledger key to standard tezos binary representation
 */
function compressPublicKey(publicKey, curve) {
    if (curve === 0x00) {
        publicKey = publicKey.slice(1);
    }
    else {
        publicKey[0] = 0x02 + (publicKey[64] & 0x01);
        publicKey = publicKey.slice(0, 33);
    }
    return publicKey;
}
function appendWatermark(bytes, watermark) {
    let transactionHex = bytes;
    if (typeof watermark !== 'undefined') {
        const hexWatermark = Buffer.from(watermark).toString('hex');
        transactionHex = hexWatermark.concat(bytes);
    }
    return transactionHex;
}
/**
 *
 * @description In order not to exceed the data length allowed by the Ledger device, split the operation into buffers of 230 bytes (max) and add them to the message to send to the Ledger
 * @param messageToSend The message to send to the Ledger device
 * @param operation The operation which will be chunk if its length is over 230 bytes
 * @returns The instruction to send to the Ledger device
 */
function chunkOperation(messageToSend, operation) {
    let offset = 0;
    while (offset !== operation.length) {
        const chunkSize = offset + MAX_CHUNK_SIZE >= operation.length ? operation.length - offset : MAX_CHUNK_SIZE;
        const buff = Buffer.alloc(chunkSize);
        operation.copy(buff, 0, offset, offset + chunkSize);
        messageToSend.push(buff);
        offset += chunkSize;
    }
    return messageToSend;
}
/**
 *
 * @description Verify if the signature returned by the ledger for tz2 and tz3 is valid
 * @param response The signature returned by the Ledger (return from the signWithLedger function)
 * @returns True if valid, false otherwise
 */
function validateResponse(response) {
    let valid = true;
    if (response[0] !== 0x31 && response[0] !== 0x30) {
        valid = false;
    }
    if (response[1] + 4 !== response.length) {
        valid = false;
    }
    if (response[2] !== 0x02) {
        valid = false;
    }
    const rLength = response[3];
    if (response[4 + rLength] !== 0x02) {
        valid = false;
    }
    const idxLengthSVal = 5 + rLength;
    const sLength = response[idxLengthSVal];
    if (idxLengthSVal + 1 + sLength + 2 !== response.length) {
        valid = false;
    }
    return valid;
}
/**
 *
 * @description Extract a part of the response returned by the Ledger
 * @param idxLength The index in the response from the Ledger that corresponds to the length of the part to extract
 * @param response The signature returned by the Ledger (return from the signWithLedger function)
 * @returns An object that contains the extracted buffer, the index where it starts in the response and the length of the extracted part
 */
function extractValue(idxLength, response) {
    const buffer = Buffer.alloc(32);
    buffer.fill(0);
    let length = response[idxLength];
    let idxValueStart = idxLength + 1;
    if (length > 32) {
        idxValueStart += length - 32;
        length = 32;
    }
    response.copy(buffer, 32 - length, idxValueStart, idxValueStart + length);
    return { buffer, idxValueStart, length };
}

/**
 *  @category Error
 *  @description Error that indicates an invalid or unparseable ledger response
 */
class InvalidLedgerResponseError extends Error {
    constructor(message) {
        super(message);
        this.message = message;
        this.name = 'InvalidLedgerResponseError';
    }
}
/**
 *  @category Error
 *  @description Error that indicates a failure when trying to retrieve a Public Key from Ledger signer
 */
class PublicKeyRetrievalError extends Error {
    constructor() {
        super(`Unable to retrieve Public Key from Ledger`);
        this.name = 'PublicKeyRetrievalError';
    }
}
/**
 *  @category Error
 *  @description Error that indicates a failure when trying to retrieve a Public Key Hash from Ledger signer
 */
class PublicKeyHashRetrievalError extends Error {
    constructor() {
        super(`Unable to retrieve Public Key Hash from Ledger`);
        this.name = 'PublicKeyHashRetrievalError';
    }
}

// IMPORTANT: THIS FILE IS AUTO GENERATED! DO NOT MANUALLY EDIT OR CHECKIN!
const VERSION = {
    "commitHash": "6d90b3d5e616a6e9b9ad9dd8453b5068e7396fff",
    "version": "13.0.1"
};

/**
 * @packageDocumentation
 * @module @taquito/ledger-signer
 */
var DerivationType;
(function (DerivationType) {
    DerivationType[DerivationType["ED25519"] = 0] = "ED25519";
    DerivationType[DerivationType["SECP256K1"] = 1] = "SECP256K1";
    DerivationType[DerivationType["P256"] = 2] = "P256";
})(DerivationType || (DerivationType = {}));
/**
 *  @category Error
 *  @description Error that indicates an invalid derivation type being passed or used
 */
class InvalidDerivationTypeError extends Error {
    constructor(derivationType) {
        super(`The derivation type ${derivationType} is invalid. The derivation type must be DerivationType.ED25519, DerivationType.SECP256K1 or DerivationType.P256`);
        this.derivationType = derivationType;
        this.name = 'InvalidDerivationTypeError';
    }
}
/**
 *  @category Error
 *  @description Error that indicates an invalid derivation path being passed or used
 */
class InvalidDerivationPathError extends Error {
    constructor(derivationPath) {
        super(`The derivation path ${derivationPath} is invalid. The derivation path must start with 44'/1729`);
        this.derivationPath = derivationPath;
        this.name = 'InvalidDerivationPathError';
    }
}
const HDPathTemplate = (account) => {
    return `44'/1729'/${account}'/0'`;
};
/**
 *
 * @description Implementation of the Signer interface that will allow signing operation from a Ledger Nano device
 *
 * @param transport A transport instance from LedgerJS libraries depending on the platform used (e.g. Web, Node)
 * @param path The ledger derivation path (default is "44'/1729'/0'/0'")
 * @param prompt Whether to prompt the ledger for public key (default is true)
 * @param derivationType The value which defines the curve to use (DerivationType.ED25519(default), DerivationType.SECP256K1, DerivationType.P256)
 *
 * @example
 * ```
 * import TransportNodeHid from "@ledgerhq/hw-transport-node-hid";
 * const transport = await TransportNodeHid.create();
 * const ledgerSigner = new LedgerSigner(transport, "44'/1729'/0'/0'", false, DerivationType.ED25519);
 * ```
 *
 * @example
 * ```
 * import TransportU2F from "@ledgerhq/hw-transport-u2f";
 * const transport = await TransportU2F.create();
 * const ledgerSigner = new LedgerSigner(transport, "44'/1729'/0'/0'", true, DerivationType.SECP256K1);
 * ```
 */
class LedgerSigner {
    constructor(transport, path = "44'/1729'/0'/0'", prompt = true, derivationType = DerivationType.ED25519) {
        this.transport = transport;
        this.path = path;
        this.prompt = prompt;
        this.derivationType = derivationType;
        // constants for APDU requests (https://github.com/obsidiansystems/ledger-app-tezos/blob/master/APDUs.md)
        this.CLA = 0x80; // Instruction class (always 0x80)
        this.INS_GET_PUBLIC_KEY = 0x02; // Instruction code to get the ledger’s internal public key without prompt
        this.INS_PROMPT_PUBLIC_KEY = 0x03; // Instruction code to get the ledger’s internal public key with prompt
        this.INS_SIGN = 0x04; // Sign a message with the ledger’s key
        this.FIRST_MESSAGE_SEQUENCE = 0x00;
        this.LAST_MESSAGE_SEQUENCE = 0x81;
        this.OTHER_MESSAGE_SEQUENCE = 0x01;
        this.transport.setScrambleKey('XTZ');
        if (!path.startsWith("44'/1729'")) {
            throw new InvalidDerivationPathError(path);
        }
        if (!Object.values(DerivationType).includes(derivationType)) {
            throw new InvalidDerivationTypeError(derivationType.toString());
        }
    }
    publicKeyHash() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!this._publicKeyHash) {
                yield this.publicKey();
            }
            if (this._publicKeyHash) {
                return this._publicKeyHash;
            }
            throw new PublicKeyHashRetrievalError();
        });
    }
    publicKey() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._publicKey) {
                return this._publicKey;
            }
            const responseLedger = yield this.getLedgerPublicKey();
            const publicKeyLength = responseLedger[0];
            const rawPublicKey = responseLedger.slice(1, 1 + publicKeyLength);
            const compressedPublicKey = compressPublicKey(rawPublicKey, this.derivationType);
            const prefixes = this.getPrefixes();
            const publicKey = b58cencode(compressedPublicKey, prefixes.prefPk);
            const publicKeyHash = b58cencode(hash(compressedPublicKey, 20), prefixes.prefPkh);
            this._publicKey = publicKey;
            this._publicKeyHash = publicKeyHash;
            return publicKey;
        });
    }
    getLedgerPublicKey() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                let ins = this.INS_PROMPT_PUBLIC_KEY;
                if (this.prompt === false) {
                    ins = this.INS_GET_PUBLIC_KEY;
                }
                const responseLedger = yield this.transport.send(this.CLA, ins, this.FIRST_MESSAGE_SEQUENCE, this.derivationType, transformPathToBuffer(this.path));
                return responseLedger;
            }
            catch (error) {
                throw new PublicKeyRetrievalError();
            }
        });
    }
    secretKey() {
        return __awaiter(this, void 0, void 0, function* () {
            throw new ProhibitedActionError('Secret key cannot be exposed');
        });
    }
    sign(bytes, watermark) {
        return __awaiter(this, void 0, void 0, function* () {
            const watermarkedBytes = appendWatermark(bytes, watermark);
            const watermarkedBytes2buff = Buffer.from(watermarkedBytes, 'hex');
            let messageToSend = [];
            messageToSend.push(transformPathToBuffer(this.path));
            messageToSend = chunkOperation(messageToSend, watermarkedBytes2buff);
            const ledgerResponse = yield this.signWithLedger(messageToSend);
            let signature;
            if (this.derivationType === DerivationType.ED25519) {
                signature = ledgerResponse.slice(0, ledgerResponse.length - 2).toString('hex');
            }
            else {
                if (!validateResponse(ledgerResponse)) {
                    throw new InvalidLedgerResponseError('Cannot parse ledger response');
                }
                const idxLengthRVal = 3; // Third element of response is length of r value
                const rValue = extractValue(idxLengthRVal, ledgerResponse);
                const idxLengthSVal = rValue.idxValueStart + rValue.length + 1;
                const sValue = extractValue(idxLengthSVal, ledgerResponse);
                const signatureBuffer = Buffer.concat([rValue.buffer, sValue.buffer]);
                signature = signatureBuffer.toString('hex');
            }
            return {
                bytes,
                sig: b58cencode(signature, prefix[Prefix.SIG]),
                prefixSig: b58cencode(signature, this.getPrefixes().prefSig),
                sbytes: bytes + signature,
            };
        });
    }
    signWithLedger(message) {
        return __awaiter(this, void 0, void 0, function* () {
            // first element of the message represents the path
            let ledgerResponse = yield this.transport.send(this.CLA, this.INS_SIGN, this.FIRST_MESSAGE_SEQUENCE, this.derivationType, message[0]);
            for (let i = 1; i < message.length; i++) {
                const p1 = i === message.length - 1 ? this.LAST_MESSAGE_SEQUENCE : this.OTHER_MESSAGE_SEQUENCE;
                ledgerResponse = yield this.transport.send(this.CLA, this.INS_SIGN, p1, this.derivationType, message[i]);
            }
            return ledgerResponse;
        });
    }
    getPrefixes() {
        if (this.derivationType === DerivationType.ED25519) {
            return {
                prefPk: prefix[Prefix.EDPK],
                prefPkh: prefix[Prefix.TZ1],
                prefSig: prefix[Prefix.EDSIG],
            };
        }
        else if (this.derivationType === DerivationType.SECP256K1) {
            return {
                prefPk: prefix[Prefix.SPPK],
                prefPkh: prefix[Prefix.TZ2],
                prefSig: prefix[Prefix.SPSIG],
            };
        }
        else {
            return {
                prefPk: prefix[Prefix.P2PK],
                prefPkh: prefix[Prefix.TZ3],
                prefSig: prefix[Prefix.P2SIG],
            };
        }
    }
}

export { DerivationType, HDPathTemplate, InvalidDerivationPathError, InvalidDerivationTypeError, LedgerSigner, VERSION };
//# sourceMappingURL=taquito-ledger-signer.es6.js.map
